\documentclass[twocolumn]{article}
\usepackage{listings}
\usepackage[scaled]{beramono}\usepackage[T1]{fontenc}\usepackage[utf8]{inputenc}\usepackage[margin = 0.3in, top=0.6in, landscape]{geometry}
\setlength{\columnseprule}{0.4pt}\setlength{\columnsep}{40pt}
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhead[L]{Pumazos - Facultad de Ciencias UNAM}\fancyhead[C]{\textsl{\leftmark}}\fancyhead[R]{\thepage}\begin{document}
\setlength{\parindent=0pt}
\section{Graficas}
\subsection{Kruskal}
\begin{footnotesize}{\bf Descripción:} Encuentra un árbol generador de peso mínimo para una gráfica.


{\bf Complejidad:} $\mathcal{O}(E \log E)$


{\bf Dependencias:} \texttt{Estructuras/Union Find}
\end{footnotesize}\lstset{basicstyle=\footnotesize\ttfamily,breaklines=true,tabsize=2,language=C++,frame=leftline, numbers=left, numberstyle=\tiny, numbersep=5pt}
\begin{lstlisting}
struct edge {
	int u, v, w;
	bool operator< (const edge &o) const{ return w < o.w; }
};
vector<edge> edges;
int kruskal() {
	int res = 0;
	sort(edges.begin(), edges.end());
	for(auto e : edges) if(join(e.u, e.v))
		res += e.w; // uv es arista del MST
	return res;
}
\end{lstlisting}
\subsection{LCA}
\begin{footnotesize}{\bf Descripción: } Calcula saltos de potencias de $2$ en un árbol y calcula el ancestro común más cercano de dos vértices.


{\bf Complejidad: } $\mathcal{O}(n \log n)$ en construcción. $\mathcal{O}(\log n)$ por query.
\end{footnotesize}\lstset{basicstyle=\footnotesize\ttfamily,breaklines=true,tabsize=2,language=C++,frame=leftline, numbers=left, numberstyle=\tiny, numbersep=5pt}
\begin{lstlisting}
const int MAXN = 1e6, LOG = 20;
vector<int> adj[MAXN];
int up[LOG][MAXN], dep[MAXN];
void dfs(int s, int p = 0) {
	up[0][s] = (p ?: s);
	dep[s] = (p ? dep[p] + 1 : s);
	for(auto v : adj[s]) if(v != s) dfs(v, s);
}
void build() {
	dfs(1);
	for(int l = 1; l < LOG; l++) for(int v = 1; v < MAXN; v++)
		up[l][v] = up[l - 1][up[l - 1][v]];
}
void jmp(int &u, int v, int d) {
	for(int l = LOG - 1; l >= 0; l--) if(d & (1 << l))
			u = up[l][u];
}
int LCA(int u, int v) {
	if(dep[u] < dep[v]) swap(u, v);
	jmp(u, v, dep[u] - dep[v]);
	if(u == v) return u;
	for(int l = LOG - 1; l >= 0; l--)
		if(up[l][u] != up[l][v])
			u = up[l][u], v = up[l][v];
	return up[0][u];
}
\end{lstlisting}
\subsection{Floyd}
\begin{footnotesize}{\bf Descripción:} Calcula la distancia mínima entre cualesquiera dos vértices de una gráfica dirigida.


{\bf Complejidad:} $\mathcal{O}(n^3)$
\end{footnotesize}\lstset{basicstyle=\footnotesize\ttfamily,breaklines=true,tabsize=2,language=C++,frame=leftline, numbers=left, numberstyle=\tiny, numbersep=5pt}
\begin{lstlisting}
const int MAXN = 500, INF = 1e9;
int G[MAXN][MAXN], n;
void floyd() {
	for(int k = 0; k < n; k++)
		for(int i = 0; i < n; i++)
			for(int j = 0; j < n; j++)
				G[i][j] = min(G[i][j], G[i][k] + G[k][j]);
}
\end{lstlisting}
\subsection{Vertices y Aristas de Corte}
\begin{footnotesize}{\bf Descripción: } Encuentra vértices de corte y aristas de corte (puentes) en una gráfica.


{\bf Complejidad: } $\mathcal{O}(V + E)$
\end{footnotesize}\lstset{basicstyle=\footnotesize\ttfamily,breaklines=true,tabsize=2,language=C++,frame=leftline, numbers=left, numberstyle=\tiny, numbersep=5pt}
\begin{lstlisting}
const int MAXN = 1e5;
int low[MAXN], ord[MAXN], tin;
vector<int> adj[MAXN];
int dfs(int s) {
	low[s] = ord[s] = ++tin;
	for(auto v : adj[s]) {
		if(!low[v]) {
			dfs(v);
			if(low[v] > ord[s]) { /* uv es puente */ }
			if(low[v] >= ord[s]) { /* u es punto de articulacion (o raiz) */}
			low[s] = min(low[s], low[v]);
		}
		else if(ord[v] < ord[s])
			low[s] = min(low[s], ord[v]);
	}
	return low[s];
}
\end{lstlisting}
\subsection{SCC}
\begin{footnotesize}{\bf Descripción: } Encuentra componentes fuertemente conexas en una gráfica dirigida (Tarjan).


{\bf Complejidad: } $\mathcal{O}(V + E)$
\end{footnotesize}\lstset{basicstyle=\footnotesize\ttfamily,breaklines=true,tabsize=2,language=C++,frame=leftline, numbers=left, numberstyle=\tiny, numbersep=5pt}
\begin{lstlisting}
vi val, comp, sta;
int Time, ncomps;
template<class G> int dfs(int s, G &g) {
	int low = val[s] = ++Time, x; sta.push_back(s);
	for(auto v : g[s]) if(comp[v] < 0)
		low = min(low, val[v] ?: dfs(v, g));
	if(low == val[s]) {
		do {
			x = sta.back(); sta.pop_back();
			comp[x] = ncomps;
		} while(x != s);
		ncomps++;
	}
}
template<class G> int scc(G &g) {
	int n = g.size();
	comp.assign(n, -1), val.assign(0, -1);
	Time = ncomps = 0;
	for(int i = 0; i < n; i++) if(comp[i] < 0) dfs(i, g);
}
\end{lstlisting}
\section{Strings}
\subsection{Z Function}
\begin{footnotesize}{\bf Descripción: } Calcula $z[i] = $ máximo $L$ tal que $s[i : i + L) = s[0 : L)$ para cada $i$. Útil para string matching.


{\bf Complejidad: } $\mathcal{O}(n)$
\end{footnotesize}\lstset{basicstyle=\footnotesize\ttfamily,breaklines=true,tabsize=2,language=C++,frame=leftline, numbers=left, numberstyle=\tiny, numbersep=5pt}
\begin{lstlisting}
vi z_func(string &s) {
	int n = s.length(), l = -1, r = -1;
	vi z(n);
	for(int i = 1; i < n; i++) {
		if(i <= r) z[i] = min(z[i - l], r - i + 1);
		while(i + z[i] < n && s[z[i]] == s[i + z[i]]) z[i]++;
		if(i + z[i] - 1 > r) l = i, r = i + z[i] - 1;
	}
	return z;
}
\end{lstlisting}
\subsection{Manacher}
\begin{footnotesize}{\bf Descripción: } Calcula $p[i] = $ máximo $L$ tal que $s[i - L : i + L]$ es capicua.


{\bf Complejidad: } $\mathcal{O}(n)$
\end{footnotesize}\lstset{basicstyle=\footnotesize\ttfamily,breaklines=true,tabsize=2,language=C++,frame=leftline, numbers=left, numberstyle=\tiny, numbersep=5pt}
\begin{lstlisting}
vi manacher(string &s) {
	// Encuentra palindromos de longitud impar.
	int n = s.length(), l = -1, r = -1;
	vi p(n);
	for(int i = 0; i < n; i++) {
		if(i <= r) p[i] = min(p[l + r - i], r - i);
		while(i+p[i]+1 < n && i-p[i]-1 >= 0 && s[i+p[i]+1] == s[i-p[i]-1]) p[i]++;
		if(i + p[i] > r) l = i - p[i], r = i + p[i];
	}
	return p;
}
\end{lstlisting}
\subsection{Suffix Array}
\begin{footnotesize}{\bf Descripción: } Crea $SA$ tal que $s[SA[i]:n] \leq s[SA[i + 1]:n]$ para todo $i$.


{\bf Complejidad: } $\mathcal{O}(n \log n)$
\end{footnotesize}\lstset{basicstyle=\footnotesize\ttfamily,breaklines=true,tabsize=2,language=C++,frame=leftline, numbers=left, numberstyle=\tiny, numbersep=5pt}
\begin{lstlisting}
const int MAXN = 5e5 + 10;
string s;
int SA[MAXN], LCP[MAXN], val[MAXN], cnt[MAXN], n;

void csort(int l) {
	int mx = max(300, n), sum = 0, tSA[MAXN];
	fill(cnt, cnt + mx, 0);
	for(int i = 0; i < n; i++)
		cnt[(SA[i] + l < n) ? val[SA[i] + l] : 0]++;
	for(int i = 0; i < mx; i++)
		{int t = cnt[i]; cnt[i] = sum; sum += t;}
	for(int i = 0; i < n; i++)
		tSA[cnt[SA[i] + l < n ? val[SA[i] + l] : 0]++] = SA[i];
	for(int i = 0; i < n; i++)
		SA[i] = tSA[i];
}
void buildSA() {
	n = s.length();
	int nval[MAXN], rk, l = 1;
	iota(SA, SA + n, 0);
	for(int i = 0; i < n; i++)
		val[SA[i]] = s[i];
	do {
		csort(l);
		csort(0);
		nval[SA[0]] = rk = 0;
		for(int i = 1; i < n; i++) nval[SA[i]] =
			ii{val[SA[i]],val[SA[i]+l]} == ii{val[SA[i-1]],val[SA[i - 1]+l]} ? rk:++rk;
		for(int i = 0; i < n; i++)
			val[i] = nval[i];
		l <<= 1;
	} while(val[SA[n - 1]] != n - 1 && l < n);
}
void buildLCP() { // LCP[i] = LCP(s[SA[i - 1]:n], s[SA[i]:n])
	int pre[MAXN], PLCP[MAXN], L = 0;
	pre[SA[0]] = -1;
	for(int i = 1; i < n; i++)
		pre[SA[i]] = SA[i - 1];
	for(int i = 0; i < n; i++) {
		if(pre[i] == -1) {
			PLCP[i] = -1;
			continue;
		}
		while(s[i + L] == s[pre[i] + L]) L++;
		PLCP[i] = L;
		L = max(0, L - 1);
	}
	for(int i = 0; i < n; i++)
		LCP[i] = PLCP[SA[i]];
}
\end{lstlisting}
\subsection{Hashing}
\begin{footnotesize}{\bf Descripción: } Calcula un rolling hash de una string para comparar substrings rápidamente.


{\bf Complejidad: } $\mathcal{O}(n)$ para construir, $\mathcal{O}(1)$ por query. Un poco lento en la práctica.
\end{footnotesize}\lstset{basicstyle=\footnotesize\ttfamily,breaklines=true,tabsize=2,language=C++,frame=leftline, numbers=left, numberstyle=\tiny, numbersep=5pt}
\begin{lstlisting}
struct rhash {
	ll P, Q;  // P ~ cantidad de caracteres del alfabeto, Q ~ 10^9
	vl H, po; // Se pueden usar varios hashes si las colisiones son problema
	rhash(string &s, ll P, ll Q) : P(P), Q(Q) {
		int n = s.length(); H.resize(n); po.resize(n);
		po[0] = 1; H[0] = s[0];
		for(int i = 1; i < n; i++) {
			H[i] = (P*H[i - 1] + s[i])%Q;
			po[i] = (po[i - 1] * P)%Q;
		}
	}
	ll get(ll l, ll r) { // Hash de s[l, r]
		if(l == 0) return H[r];
		ll res = (H[r] - po[r - l + 1]*H[l - 1])%Q;
		return res >= 0 ? res : res + Q;
	}
};
\end{lstlisting}
\section{Geometria}
\subsection{Punto}
\begin{footnotesize}{\bf Descripción: } Estructura genérica para representar puntos (vectores) en 2D.
\end{footnotesize}\lstset{basicstyle=\footnotesize\ttfamily,breaklines=true,tabsize=2,language=C++,frame=leftline, numbers=left, numberstyle=\tiny, numbersep=5pt}
\begin{lstlisting}
template<class T>
struct pt {
	T x, y;
	pt(T x = 0, T y = 0) : x(x), y(y) {}
	bool operator< (pt o) const {return (x < o.x || (x == o.x && y < o.y)); }
	bool operator== (pt o) const {return (x == o.x && y == o.y);}
	pt operator+ (pt o) const {return pt(x + o.x, y + o.y);}
	pt operator- (pt o) const {return pt(x - o.x, y - o.y);}
	pt operator* (T l) const {return pt(l*x, l*y);}
	pt operator/ (T l) const {return pt(x/l, y/l);}
	T dot(pt o) { return x*o.x + y*o.y; }
	T cross(pt o) { return x*o.y - y*o.x; }
	T cross(pt a, pt b) { return (a - *this).cross(b - *this); }
	T normsq(pt o) { return x*x +y*y; }
	double norm(pt o) { return hypot(x, y); }
};
\end{lstlisting}
\subsection{Envolvente}
\begin{footnotesize}{\bf Descripción: } Encuentra la envolvente convexa de un conjunto de puntos. Si un punto está en el interior estricto de un segmento de la frontera no se considera vértice de la envolvente.


{\bf Complejidad: } $\mathcal{O}(n \log n)$


{\bf Dependencias: } \texttt{Geometria/Punto}
\end{footnotesize}\lstset{basicstyle=\footnotesize\ttfamily,breaklines=true,tabsize=2,language=C++,frame=leftline, numbers=left, numberstyle=\tiny, numbersep=5pt}
\begin{lstlisting}
vector<pt<ll>> convex_hull(vector<pt<ll>> P) {
	int n = P.size();
	if(n <= 2) return P;
	vector<pt<ll>> L, U;
	sort(P.begin(), P.end());
	for(int i = 0; i < n; i++) {
		while(U.size() >= 2 && U[U.size() - 2].cross(U[U.size() - 1], P[i]) >= 0)
			U.pop_back();
		while(L.size() >= 2 && L[L.size() - 2].cross(L[L.size() - 1], P[n-i-1]) >= 0)
			L.pop_back();
		U.push_back(P[i]), L.push_back(P[n - i - 1]);
	}
	U.insert(U.end(), L.begin() + 1, L.end() - 1);
	return U;
}
\end{lstlisting}
\section{Flujo}
\subsection{Push-Relabel}
\begin{footnotesize}{\bf Descripción: } Highest Label Preflow Push con gap heuristic. Calcula un flujo máximo en una red.


{\bf Complejidad: } $\mathcal{O}(V^2\sqrt{E})$
\end{footnotesize}\lstset{basicstyle=\footnotesize\ttfamily,breaklines=true,tabsize=2,language=C++,frame=leftline, numbers=left, numberstyle=\tiny, numbersep=5pt}
\begin{lstlisting}
const int MAXN = 5000 + 5;
struct Edge {
	int to, rev;
	ll flow, cap;
};
vector<Edge> adj[MAXN];
void addEdge(int u, int v, int c, int r = 0) {
	Edge a = {v, (int)adj[v].size(), 0, c};
	Edge b = {u, (int)adj[u].size(), 0, r};
	adj[u].push_back(a);
	adj[v].push_back(b);
}
ll ex[MAXN];
vi hs[2*MAXN];
int H[MAXN], ptr[MAXN], n;
void push(Edge &e, ll f) {
	Edge &back = adj[e.to][e.rev];
	if(!ex[e.to] && f) hs[H[e.to]].push_back(e.to);
	e.flow += f; e.cap -= f; ex[e.to] += f;
	back.flow -= f; back.cap += f; ex[back.to] -= f;
}
ll maxflow(int s, int t) {
	H[s] = n; ex[t] = 1;
	vi cnt(2*n); cnt[0] = n - 1;
	for(auto e : adj[s]) push(e, e.cap);

	for(int ch = 0;;) {
		while(hs[ch].empty())
			if(!ch--) return -ex[s];
		int u = hs[ch].back(); hs[ch].pop_back();
		while(ex[u] > 0) {
			if(ptr[u] == adj[u].size()) {
				ptr[u] = 0;
				H[u]++;
				cnt[ch]--;
				cnt[H[u]]++;
				if(!cnt[ch] && ch < n) {
					for(int v = 1; v <= n; v++) {
						if(H[v] > ch && H[v] < n) {
							--cnt[H[v]], H[v] = n + 1;
						}
					}
				}
				ch = H[u];
			}
			else {
				Edge &e = adj[u][ptr[u]];
				if(e.cap && H[u] ==  H[e.to] + 1)
					push(e, min(ex[u], e.cap));
				else ++ptr[u];
			}
		}
	}
}
\end{lstlisting}
\subsection{Dinic}
\begin{footnotesize}{\bf Descripción:} Encuentra un flujo máximo en una red. Incluye scaling para casos malvados anti-Dinic.


{\bf Complejidad:} $\mathcal{O}(V^2E)$ sin scaling. $\mathcal{O}(VE\log(\max))$ con scaling. $\mathcal{O}(E\sqrt{V})$ para matchings. Rápido en la práctica.
\end{footnotesize}\lstset{basicstyle=\footnotesize\ttfamily,breaklines=true,tabsize=2,language=C++,frame=leftline, numbers=left, numberstyle=\tiny, numbersep=5pt}
\begin{lstlisting}
typedef long long ll;

const int MAXN = 5005, INF = 1e9;
const bool scale = false; // Magia. O(VElog(max)), pero peor constante.
int dist[MAXN], ptr[MAXN], src, dst, lim = 1;
struct Edge {
	int to, rev, f, cap;
};
vector<Edge> G[MAXN];
void addEdge(int u, int v, int c, int r = 0) {
	Edge a = {v, (int)G[v].size(), 0, c};
	Edge b = {u, (int)G[u].size(), 0, r};
	G[u].push_back(a);
	G[v].push_back(b);
}
bool bfs() {
	queue<int> q({src});
	memset(dist, -1, sizeof dist);
	dist[src] = 0;
	while(!q.empty() && dist[dst] == -1) {
		int u = q.front();
		q.pop();
		for(auto e : G[u]) {
			int v = e.to;
			if(dist[v] == -1 && e.f < e.cap && (!scale || e.cap - e.f >= lim)) {
				dist[v] = dist[u] + 1;
				q.push(v);
			}
		}
	}
	return dist[dst] != -1;
}
int dfs(int u, int f) {
	if(u == dst || !f) return f;
	for(int &i = ptr[u]; i < G[u].size(); i++) {
		Edge &e = G[u][i];
		int v = e.to;
		if(dist[v] != dist[u] + 1) continue;
		if(int df = dfs(v, min(f, e.cap - e.f))) {
			e.f += df;
			G[v][e.rev].f -= df;
			return df;
		}
	}
	return 0;
}
long long dinic() {
	long long mf = 0;
	for(lim = (scale ? (1 << 30) : 1); lim > 0; lim >>= 1) {
		while(bfs()) {
			memset(ptr, 0, sizeof ptr);
			while(long long pushed = dfs(src, INF))
				mf += pushed;
		}
	}
	return mf;
}
\end{lstlisting}
\section{Estructuras}
\subsection{CHT}
\begin{footnotesize}{\bf Descripción:} Mantiene una envolvente $S$ con queries de agregar lineas $y = mx + b$ y queries para $\max_{(m, b)\in S} mx + b$.


{\bf Complejidad:} $\mathcal{O}(\log n)$ amortizado por query.
\end{footnotesize}\lstset{basicstyle=\footnotesize\ttfamily,breaklines=true,tabsize=2,language=C++,frame=leftline, numbers=left, numberstyle=\tiny, numbersep=5pt}
\begin{lstlisting}
bool Q;
struct Line {
	mutable ll m, b, p;
	bool operator<(const Line& o) const {
		return Q ? p < o.p : m < o.m;
	}
};
struct LineContainer : multiset<Line> {
	const ll inf = LLONG_MAX;
	ll div(ll a, ll b) {
		return a / b - ((a ^ b) < 0 && a % b); }
	bool isect(iterator x, iterator y) {
		if (y == end()) { x->p = inf; return false; }
		if (x->m == y->m) x->p = x->b > y->b ? inf : -inf;
		else x->p = div(y->b - x->b, x->m - y->m);
		return x->p >= y->p;
	}
	void add(ll m, ll b) {
		auto z = insert({m, b, 0}), y = z++, x = y;
		while (isect(y, z)) z  = erase(z);
		if (x != begin() && isect(--x, y)) isect(x, y = erase(y));
		while ((y = x) != begin() && (--x)-> p >= y->p)
			isect(x, erase(y));
	}
	ll query(ll x) {
		assert(!empty());
		Q = 1; auto l = *lower_bound({0, 0, x}); Q = 0;
		return l.m * x + l.b;
	}
};
\end{lstlisting}
\subsection{Union Find}
\begin{footnotesize}{\bf Descripción:} Union Find con path compression y union by size. Mantiene representantes de una unión disjunta.


{\bf Complejidad:} $\mathcal{O}(\alpha(n))$ amortizado.
\end{footnotesize}\lstset{basicstyle=\footnotesize\ttfamily,breaklines=true,tabsize=2,language=C++,frame=leftline, numbers=left, numberstyle=\tiny, numbersep=5pt}
\begin{lstlisting}
const int MAXN = 1e6;
int rep[MAXN], sz[MAXN];
void init() {
	fill(rep, rep + MAXN, -1), fill(sz, sz + MAXN, 1);
}
int find(int u) {
	return (rep[u] == -1) ? u : rep[u] = find(rep[u]);
}
bool join(int u, int v) {
	u = find(u), v = find(v);
	if(u == v) return false;
	if(sz[u] < sz[v]) swap(u, v);
	return sz[u] += sz[v], rep[v] = u, true;
}
\end{lstlisting}
\subsection{Treap}
\lstset{basicstyle=\footnotesize\ttfamily,breaklines=true,tabsize=2,language=C++,frame=leftline, numbers=left, numberstyle=\tiny, numbersep=5pt}
\begin{lstlisting}
const int SEED = 17111999;
struct treap {
	int k, p, cnt;
	treap *l, *r;
	treap() {}
	treap(int k, int p) : k(k), p(p), l(nullptr), r(nullptr){}
};
typedef treap* ptreap;
inline int cnt(ptreap t) { return t ? t->cnt : 0; }
inline void upd(ptreap t) { if(t) t->cnt = 1 + cnt(t->l) + cnt(t->r); }
void split(ptreap t, ll k, ptreap &l, ptreap &r) {
	if(!t)
		l = r = nullptr;
	else if (k < t->k)
		split(t->l, k, l, t->l), r = t;
	else
		split(t->r, k, t->r, r), l = t;
	upd(t);
}
void merge(ptreap &t, ptreap l, ptreap r) {
	if(!l || !r)
		t = l ? l : r;
	else if(l.p > r.p)
		merge(l->r, l->r, r), t = l;
	else
		merge(r->l, l, r->l), t = r;
	upd(t);
}
void insert(ptreap &t, ptreap x) {
	if(!t)
		t = x;
	else if(x->p > t->p)
		split(t, x->k, x->l, x->r), t = x;
	else
		insert(x->k < t->k ? t->l : t->r, x);
	upd(t);
}
void erase(ptreap &t, int k) {
	if(!t)
		return;
	if(t->k == k)
		merge(t, t->l, t->r);
	else
		erase(k < t->k ? t->l : t->r, k);
	upd(t);
}
\end{lstlisting}
\subsection{Wavelet Tree}
\begin{footnotesize}{\bf Descripción:} Árbol que mantiene subsucesiones de un arreglo formadas por elementos con valores en ciertos intervalos. Útil para range queries de k-ésimo elemento o número de elementos debajo de cierta cota, etc.


{\bf Complejidad:} $\mathcal{O}(\log(\max A))$ por query.
\end{footnotesize}\lstset{basicstyle=\footnotesize\ttfamily,breaklines=true,tabsize=2,language=C++,frame=leftline, numbers=left, numberstyle=\tiny, numbersep=5pt}
\begin{lstlisting}
struct wnode {
	wnode *left, *right;
	int lo, hi;
	vector<int> c;
	wnode(int lo, int hi, int* st, int* en) : lo(lo), hi(hi) {
		if(hi == lo || st == en)
			return;
		int mi = (lo + hi)/2;
		auto f = [mi](int x) { return x <= mi; };
		c.push_back(0);
		for(auto it = st; it != en; ++it)
			c.push_back(c.back() + f(*it));
		auto it = stable_partition(st, en, f);
		left = new wnode(lo, mi, st, it);
		right = new wnode(mi + 1, hi, it, en);
	}
	int kth(int L, int R, int k) {
		if(lo == hi)
			return lo;
		int der = c[R], izq = c[L - 1], tol = der - izq;
		if(tol >= k)
			return left->kth(izq + 1, der, k);
		return right->kth(L - izq, R - der, k - tol);
	}
};
\end{lstlisting}
\subsection{Segment Tree}
\begin{footnotesize}{\bf Descripción:} Segment Tree recursivo para RMQ y similares. Los intervalos son cerrados.


{\bf Complejidad:} $\mathcal{O}(\log n)$ en updates y queries.
\end{footnotesize}\lstset{basicstyle=\footnotesize\ttfamily,breaklines=true,tabsize=2,language=C++,frame=leftline, numbers=left, numberstyle=\tiny, numbersep=5pt}
\begin{lstlisting}
const int NE = 1e9;
struct node {
	int mn, l, r;
	node *left, *right;
	node(int l, int r, int* A) : l(l), r(r) {
		if(l == r)
			mn = A[l];
		else {
			int mi = (l + r)/2;
			left = new node(l, mi, A);
			right = new node(mi + 1, r, A);
			mn = min(left->mn, right->mn);
		}
	}
	void upd(int p, int v) {
		if(r < p || p < l)
			return;
		if(l == r) {
			mn = v;
			return;
		}
		left->upd(p, v), right->upd(p, v);
		mn = min(left->mn, right->mn);
	}
	int qry(int rl, int rr) {
		if(rr < l || r < rl)
			return NE;
		if(rl <= l && r <= rr)
			return mn;
		return min(left->qry(rl, rr), right->qry(rl, rr));
	}
};

const int MAXN = 1e5 + 5;
int a[MAXN];

\end{lstlisting}
\section{Mate}
\subsection{Miller-Rabin}
\begin{footnotesize}{\bf Descripción: } Determina si un número es primo.


{\bf Complejidad: } $\mathcal{O}((\log p)^k)$ para algún $k$ razonable. Rápido en la práctica.
\end{footnotesize}\lstset{basicstyle=\footnotesize\ttfamily,breaklines=true,tabsize=2,language=C++,frame=leftline, numbers=left, numberstyle=\tiny, numbersep=5pt}
\begin{lstlisting}
bool isprime(ll p) {
	if(p == 1) return false;
	if(p % 2 == 0) return p == 2 ? true : false;
	ll d = p - 1;
	while(d % 2 == 0) d >>= 1ll;
	for(int its = 0; its < 15; its++) {
		ll a = (rand() % (p - 1)) + 1, x = d;
		a = mpow(a, d, p);
		while(x != p - 1 && a != p - 1 && a != 1) {
			a = mmul(a, a, p);
			x *= 2ll;
		}
		if(a != p - 1 && x % 2 == 0) return false;
	}
	return true;
}
\end{lstlisting}
\subsection{Matriz}
\lstset{basicstyle=\footnotesize\ttfamily,breaklines=true,tabsize=2,language=C++,frame=leftline, numbers=left, numberstyle=\tiny, numbersep=5pt}
\begin{lstlisting}

\end{lstlisting}
\subsection{CRT}
\begin{footnotesize}{\bf Descripción: } Encuentra $x$ tal que $x \equiv x_1 \pmod{m_1}, x \equiv x_2 \pmod{m_2}$. Regresa $-1$ si tal $x$ no existe.


{\bf Complejidad: } $\mathcal{O}(\log(m_1 + m_2))$. Rápido en la práctica.
\end{footnotesize}\lstset{basicstyle=\footnotesize\ttfamily,breaklines=true,tabsize=2,language=C++,frame=leftline, numbers=left, numberstyle=\tiny, numbersep=5pt}
\begin{lstlisting}
template<typename T> void euclid(T a, T b, T &x, T &y) {
	if(!b) {x = 1, y = 0; return;}
	euclid(b, a % b, y, x);
	y -= a/b * x;
}
template<typename T> T crt(T x1, T m1, T x2, T m2) {
	T d = __gcd(m1, m2), r, s;
	if(x1 % d != x2 % d)
		return -1;
	euclid(m1, m2, r, s);
	m1 /= d, m2 /= d;
	T mod = d*m1*m2, a1 = ((m1*r)%mod*x2)%mod, a2 = ((m2*s)%mod*x1)%mod, y = (a1 + a2)%mod;
	return (y >= 0 ? y : y + mod);
}
\end{lstlisting}
\subsection{FFT}
\lstset{basicstyle=\footnotesize\ttfamily,breaklines=true,tabsize=2,language=C++,frame=leftline, numbers=left, numberstyle=\tiny, numbersep=5pt}
\begin{lstlisting}
typedef complex<double> C;
const double PI = acos(-1);

/* Para NTT:
998244353 = 119*2^23 + 1, raíz primitiva 3.
*/
vector<C> fft(vector<C> &P, vector<C> &root, vector<int> &rev) {
	int n = P.size();
	vector<C> f(n);
	for(int i = 0; i < n; i++)
		f[i] = P[rev[i]];
	for(int k = 1; k < n; k *= 2) {
		for(int i = 0; i < n; i += 2*k) {
			for(int j = 0; j < k; j++) {
				C z;
				if(j == 0) z = f[i + j + k]; 
				else z = root[j*(n/(2*k))] * f[i + j + k];
				f[i + j + k] = f[i + j] - z;
				f[i + j] = f[i + j] + z;
			}
		}
	}
	return f;
}

vector<C> conv(vector<C> A, vector<C> B) {
	int n = A.size() + B.size(), L = 32 - __builtin_clz(n);
	n = 1 << L;
	A.resize(n, 0), B.resize(n, 0);
	vector<C> root(n);
	for(int i = 0; i < n; i++)
		root[i] = polar(1.0, 2.0*PI*double(i)/double(n));
	vector<int> rev(n);
	for(int i = 1; i < n; i++)
		rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (L - 1));
	vector<C> f = fft(A, root, rev), g = fft(B, root, rev);
	for(int i = 0; i < n; i++)
		f[i] *= g[i];
	root.push_back({1, 0}); reverse(root.begin(), root.end()), root.pop_back();
	g = fft(f, root, rev);
	for(int i = 0; i < n; i++)
		g[i] /= n;
	return g;
}

\end{lstlisting}
\section{Varios}
\subsection{LIS}
\begin{footnotesize}{\bf Descripción:} Encuentra una subsucesión creciente (o estrictamente creciente) de longitud máxima.


{\bf Complejidad:} $\mathcal{O}(n \log n)$.
\end{footnotesize}\lstset{basicstyle=\footnotesize\ttfamily,breaklines=true,tabsize=2,language=C++,frame=leftline, numbers=left, numberstyle=\tiny, numbersep=5pt}
\begin{lstlisting}
vl lis(vl a) {
	int n = a.size(), sz = 0; map<pl, pl> pre;
	vl dp(n + 1, LLONG_MAX); dp[0] = LLONG_MIN;
	for(int i = 0; i < n; i++) {
		auto it = upper_bound(dp.begin(), dp.end(), a[i]); //a[i]-1 para estricta.
		if(*it == LLONG_MAX) sz++; *it = min(*it, a[i]);
		int pos = distance(dp.begin(), it); pre[{pos, a[i]}] = {pos - 1, dp[pos - 1]};
	}
	vl ans; pl cu = {sz, dp[sz]};
	do {
		ans.push_back(cu.second);
		cu = pre[cu];
	} while(cu.first);
	return reverse(ans.begin(), ans.end()), ans;
}
\end{lstlisting}
\end{document}